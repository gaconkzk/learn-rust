# FFI
[Table of Contents](toc/english.html)

---

## Efficiency!

<small>(This is Germany after all)</small>

*» efficient C bindings «*

---

Rust supports the platform-ABI.

---

Interact with shared/static libraries.

Or _be_ one.

---

*» efficient C bindings «*

<br/>

There are no conversion costs

---

## Using C from Rust

---

## Basic example

Hello world from C

---

Let's assume you _really_ want to use printf

<pre><code data-source="chapters/shared/code/ffi/1.c" data-trim="hljs rust"></code></pre>

<pre><code data-source="chapters/shared/code/ffi/1.h" data-trim="hljs rust"></code></pre>

---

## Things TODO

- Bind against functions in header
- Link the external code as a library
- Call those with `unsafe { ... }`
- Transmute data for C functions

---

## Before we get started

<pre><code data-source="chapters/shared/code/ffi/1.rs" data-trim="hljs rust"></code></pre>

Disables some Rust naming lints

<small>(which are common in C code)</small>

---

## Binding functions

<pre><code data-source="chapters/shared/code/ffi/1.h" data-trim="hljs rust"></code></pre>

<pre><code data-source="chapters/shared/code/ffi/2.rs" data-trim="hljs rust"></code></pre>

---

## Primitive types

Some type conversions can be infered by the compiler.

* `c_uint` ↔ `u32`
* `c_int` ↔ `i32`
* `c_void` ↔ `()`
* ...etc...

---

## Calling this

<pre><code data-source="chapters/shared/code/ffi/3.rs" data-trim="hljs rust"></code></pre>

---

## Cargo (build-system) support

* Build native code via build-dependency crates
  * `gcc`, `clang`, `cmake`, ...
* `build.rs` file responsible for linking code

---

## Structs

The layout of enums and structs is (currently) left to the compiler. `#[repr(C)]` directs the compiler to use the platform-layout instead. 

<pre><code data-source="chapters/shared/code/ffi/4-1.rs" data-trim="hljs rust"></code></pre>

---

## Enums

<pre><code data-source="chapters/shared/code/ffi/4-2.rs" data-trim="hljs rust"></code></pre>

---

## Opaque types

When not knowing (or caring) about internal layout, opaque structs can be used.

<pre><code data-source="chapters/shared/code/ffi/4.rs" data-trim="hljs rust"></code></pre>

---

## Callbacks

`extern "C"` applies to function pointers given to extern functions too.

<pre><code data-source="chapters/shared/code/ffi/6.rs" data-trim="hljs rust"></code></pre>

---

## Okay enough boring examples

---

## Real example

Binding imagemagick to rust!

<small>(Somebody already did that but let's do it again)</small>

---

## Utility Functions

<pre><code data-source="chapters/shared/code/ffi/7.rs" data-trim="hljs rust"></code></pre>

Important: The party that allocates deallocates!

---

## What the hell?

<pre><code data-source="chapters/shared/code/ffi/8.output" data-trim="hljs output"></code></pre>

Why is the version number architecture dependent?

---

## And now?

We have bound the functions, but there is nothing safe here.

---

## Binding of raw pointers with lifecycle management

<pre><code data-source="chapters/shared/code/ffi/9.rs" data-trim="hljs rust"></code></pre>

---

## Why like this?

-   Structs with one field vanish at runtime
-   Isolates lifecycle management of the pointer from the rest of the code
-   Older Rust versions modify the struct layout if `Drop` is implemented

---

## Handling of C Style Errors

> Error handling styles in C can be organized into one of several distinct styles, such as popular or correct. Some examples of each.

[Ted Unangst](http://www.tedunangst.com/flak/post/to-errno-or-to-error)

---

## Handling of leveldb Errors

<pre><code data-source="chapters/shared/code/ffi/10.rs" data-trim="hljs rust"></code></pre>

---

## Handling of C Strings

See [`std::ffi::CString`](https://doc.rust-lang.org/std/ffi/struct.CString.html).

Warning:Take great care to match the correct ownership semantic and use `new`, `from_raw` and possibly `std::mem::forget` correctly.

---

## Other nice gains

Lifetimes allow safe modelling of the pointer invalidation semantics of leveldb.

---

## Example

<pre><code data-source="chapters/shared/code/ffi/11.rs" data-trim="hljs rust"></code></pre>

The iterator must drop before the database drops.

This is also specified by leveldb for `leveldb_t` and `leveldb_iterator_t`.

---

## Trick: That even works without consuming memory

<pre><code data-source="chapters/shared/code/ffi/12.rs" data-trim="hljs rust"></code></pre>

PhantomData is a 0-sized type that, that fakes the presence of a reference to the database struct.

Such Optimisations should be tested with `compile-fail`!

---

## compile-fail

`compile-fail` is an extraction from the `rustc`-Testsuite and allows expressing assertions about error messages.

---

## Callbacks

<pre><code data-source="chapters/shared/code/ffi/13.rs" data-trim="hljs rust"></code></pre>

---

## Problems

-   `state: *c_void` is a way of expressing polymorphism in C
-   How do I ensure that, `c_void` always refers to the same type?
-   How do I implement the polymorphism?

---

## Generics, Traits and raw Boxes

<pre><code data-source="chapters/shared/code/ffi/14.rs" data-trim="hljs rust"></code></pre>

Important: This trait only works with boxed values!

---

## Usage

<pre><code data-source="chapters/shared/code/ffi/15.rs" data-trim="hljs rust"></code></pre>

---

## Working with Slices


Conversion of slices is also easy:

<pre><code data-source="chapters/shared/code/ffi/16.rs" data-trim="hljs rust" class="lang-rust"></code></pre>

Always keep ownership in mind!

---

## Trap

<pre><code data-source="chapters/shared/code/ffi/17.rs" data-trim="hljs rust" class="lang-rust"></code></pre>

Oops, suddenly, there's a mutable and an immutable pointer!

---

## Helpers

-   [Servo bindgen](https://github.com/servo/rust-bindgen)
-   Very advanced, can also generate bindings to C++ code


