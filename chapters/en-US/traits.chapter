# Implementation and Traits

---

Rust offers the possibility to bind functions to types.

---

# Warning

This sometimes looks like object-oriented programming, but it is not.

In particular, run-time polymorphism, messages, classes, subtypes, and method overload are missing.

---

## Simple implementations: associated function

<pre><code data-source="chapters/shared/code/traits/1.rs" data-trim="hljs rust"></code></pre>

---

## Remark

`new` here is purely convention.

---

## Python Says Hello

<pre><code data-source="chapters/shared/code/traits/2.rs" data-trim="hljs rust"></code></pre>

---

## Borrowing and Ownership of `self`

It is not unlike normal, but at the beginning somewhat unfamiliar.

-   Borrowing through one function *simultaneously grants self*.
-   This is especially applicable for mutable borrows!
-   `self` without`&`returns ownership to the value from the calling context.

---

## Interesting Differences to Common OO

-   Values can replace themselves
-   Values, for example, iterators and builders can have methods that consume `self` and are thus invalidated.
-   This solves the problem of inverting iterators.

---

## Attributes

-   Implementations can occur multiple times

---

## Self

`Self` is a special type in Rust. It always references the type to which the implementation refers.

<pre><code data-source="chapters/shared/code/traits/3.rs" data-trim="hljs rust"></code></pre>

---

## Traits

Traits are Rusts variant, abstracting over types.

---

We've already met a trait: `Debug`.

---

Traits define functions types must implement. They can then be used generically.

---

<pre><code data-source="chapters/shared/code/traits/4.rs" data-trim="hljs rust"></code></pre>

