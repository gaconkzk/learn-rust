# Iteradores

---

Los iteradores de Rust son:

* Perezosos (lazy).
* Penetrante (pervasive).
* Potencialmente infinitos.

---

## ¿De dónde vienen?

* Colecciones como `Vec<T>` tienen una función `iter()` que produce un iterador.
* Cosas como `std::net::TcpListener` produce un iterador de `TcpStream`s a través de su función `incoming()`.
* Los iteradores pueden ser implementados en otras estructuras.

---

## Usos comunes

---

## `next()`

Los iteradores puede ser manualmente incrementados:

```rust
fn main() {
    let items = vec![0, 1, 2];
    let iterator = items.iter();
    assert_eq!(iterator.next(), Some(0));
    assert_eq!(iterator.next(), Some(1));
    assert_eq!(iterator.next(), Some(1));
    assert_eq!(iterator.next(), None);
}
```

---

## `map()`

Transforman elementos mientras son evaluados:

```rust
fn main() {
    let fizzbuzz = (0..10_000)
        .map(|x| match x {
            x if x % 15 == 0 => String::from("Fizzbuzz"),
            x if x % 3  == 0 => String::from("Fizz"),
            x if x % 5  == 0 => String::from("Buzz"),
            x => format!("{}", x),
        });
    for item in fizzbuzz {
        println!("{}", item);
    }
}
```

---

## `filter()`

Filtra valores no deseados, saltando cálculos adicionales en ellos:

```rust
fn main() {
    let evens = (0..10_000)
        .filter(|x| x % 2 == 0);
    for item in evens {
        println!("{}", item);
    }
}
```

---

## `fold()`

Reduce una secuencia de valores a un valor único:

```rust
fn factorial(val: usize) -> usize {
    (1..val).rev().fold(1, |acc, x| acc * x)
}

fn main() {
    println!("{}", factorial(10));
}
```

---

## `cycle()` & `take()`

Causan que los iteradores se repitan y finalicen tempranamente:

```rust
fn main() {
    // Limita la salida a 30 para evitar un ciclo infinito.
    for item in (0..10).cycle().take(30) {
        println!("{}", item);
    }
}
```

---

## `zip()` & `unzip()`

Unen iteradores y los separan en partes también:

```rust
fn main() {
    let first = 0..10;
    let second = 10..20;

    let (first_again, _): (Vec<_>, Vec<_>) = first
        .zip(second)
        .inspect(|x| println!("Inspect: {:?}", x))
        .unzip();

    for item in first_again {
        println!("{}", item);
    }
}
```

---

## `max()` & `min()`

Devuelve el valor mínimo o máximo de un iterador.

```rust
fn main() {
    println!("{}", (0..50).max().unwrap());
    println!("{}", (0..50).min().unwrap());
}
```

---

## Gotcha

Esto no funciona

```rust
fn main() {
    let mut iter = vec![1,2,3].iter();
    println!("{:?}", iter.next());
}
```

¿Por qué? Piense acerca del alcance y propiedad (scoping & ownership!)
