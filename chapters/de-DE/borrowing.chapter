# Borrowing

---

## Was man besitzt, kann man ausleihen

---

Ownership gibt eine solide Grundsemantik, wird aber auf die Dauer unpraktisch.

---

Weiterverwenden von Daten nach einem Funktionsaufruf ist mit Ownership nicht m√∂glich, wenn die Funktion Besitz nicht wieder zur√ºck gibt.

---

Stattdessen: Ausleihen!

---

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32 
}

fn main() {
    let mut point = Point { x: 1, y: 2 };
    inspect(&point);
    point.x = 2;
    inspect(&point);
}

fn inspect(p: &Point) {
    println!("{:?}", p);
}
```

---

<pre class="diagram">
    main              inspect
+----------+
|          |
|    point |----+
|          |    |
|          |    |    +----------+
|          |    |    |          |
|          |    +----|   &point |
|          |         |          |
|          |         +----------+
+----------+
  üóë
</pre>

TODO: Diagram verbessern, mit dotted lines und so

---

Einfaches ausleihen ist beliebig oft m√∂glich.

---

Was, wenn wir die Daten aber ver√§ndern m√∂chten?

---

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32 
}

fn main() {
    let mut point = Point { x: 1, y: 2 };
    inspect(&point);
    move_point(&mut point, 3, 3);
    inspect(&point);
}

fn move_point(p: &mut Point, x: i32, y: i32) {
    p.x = x;
    p.y = y;
}

fn inspect(p: &Point) {
    println!("{:?}", p);
}
```

---

Mutable Ausleihen sind exklusiv.

---

## Zusammenfassung

Daten k√∂nnen entweder:
* Beliebig oft immutable ausgeliehen werden
* Oder exakt einmal mutabel

Ownership bleibt im Aufrufskontext, genauso wie die Deallokation

---

Was verhindert das?

---

# Sehen sie das Problem?

```rust
fn push_all(on: &mut Vec<u8>, from: &Vec<u8>) {

}
```

TODO: weitere Beispiele


---

Wichtig hierbei:
* zu jedem Typ `T` gibt es einen Typ `&T`
* zu jedem Typ `T` gibt es einen Typ `&mut T`
* `&&T` ist ein legaler Typ
* `& &mut T` ist kein legaler Typ. Warum?

---

## Borrows sind Referenzen

Das heisst, sie m√ºssen manchmal dereferenziert werden.

```rust
fn main() {
    let number: &mut i32 = 4;
    *number = 10;
    println!("{}", number);
}
```

---

## Borrows sind lexikalisch


TODO: Beispiel